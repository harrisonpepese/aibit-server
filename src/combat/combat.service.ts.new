import { Injectable } from '@nestjs/common';
import { StartAttackUseCase } from './application/use-cases/start-attack.use-case';
import { EndCombatUseCase } from './application/use-cases/end-combat.use-case';
import { GetCombatStatusUseCase } from './application/use-cases/get-combat-status.use-case';
import { ApplyEffectUseCase } from './application/use-cases/apply-effect.use-case';
import { PerformAttackDto } from './dto/perform-attack.dto';
import { EndCombatDto } from './dto/end-combat.dto';
import { CombatEvent } from './domain/entities/combat-event.entity';
import { CombatEffect, CombatEffectType } from './domain/value-objects/combat-effect.vo';

@Injectable()
export class CombatService {
  constructor(
    private readonly startAttackUseCase: StartAttackUseCase,
    private readonly endCombatUseCase: EndCombatUseCase,
    private readonly getCombatStatusUseCase: GetCombatStatusUseCase,
    private readonly applyEffectUseCase: ApplyEffectUseCase,
  ) {}

  async performAttack(attackDto: PerformAttackDto): Promise<any> {
    const event = await this.startAttackUseCase.execute(
      attackDto.attackerId,
      attackDto.targetId,
      attackDto.attackType,
      attackDto.damageType,
      attackDto.baseDamage,
      attackDto.targetDodgeChance,
      attackDto.targetBlockChance,
      attackDto.targetResistance,
      attackDto.criticalChance,
      attackDto.accuracy,
    );

    return {
      eventId: event.getId(),
      attackerId: attackDto.attackerId,
      targetId: attackDto.targetId,
      status: 'pending',
      message: 'Ataque agendado para processamento no próximo turno',
    };
  }

  async endCombat(endCombatDto: EndCombatDto): Promise<any> {
    const event = await this.endCombatUseCase.execute(
      endCombatDto.participantId,
      endCombatDto.reason,
    );

    return {
      eventId: event.getId(),
      participantId: endCombatDto.participantId,
      status: 'pending',
      message: 'Finalização de combate agendada para processamento no próximo turno',
    };
  }

  async getCombatStatus(participantId: string): Promise<any> {
    return this.getCombatStatusUseCase.execute(participantId);
  }

  async applyEffect(
    sourceId: string,
    targetId: string,
    effectType: CombatEffectType,
    value: number,
    duration: number,
    interval: number = 1,
    metadata: Record<string, any> = {},
  ): Promise<any> {
    const effect = new CombatEffect(
      effectType,
      value,
      duration,
      sourceId,
      targetId,
      interval,
      metadata,
    );

    const event = await this.applyEffectUseCase.execute(effect);

    return {
      eventId: event.getId(),
      effectType,
      sourceId,
      targetId,
      status: 'pending',
      message: 'Efeito agendado para processamento no próximo turno',
    };
  }

  // Método legado para compatibilidade
  async attack(attackerIdOrDto: string | { attackerId: string; targetId: string }, targetId?: string): Promise<any> {
    let attackerId: string;
    
    if (typeof attackerIdOrDto === 'object') {
      attackerId = attackerIdOrDto.attackerId;
      targetId = attackerIdOrDto.targetId;
    } else {
      attackerId = attackerIdOrDto;
    }

    if (!targetId) {
      throw new Error('targetId é obrigatório');
    }

    return this.performAttack({
      attackerId,
      targetId,
      attackType: 'MELEE',
      damageType: 'PHYSICAL',
      baseDamage: 10,
    } as PerformAttackDto);
  }
}
